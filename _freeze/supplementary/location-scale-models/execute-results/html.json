{
  "hash": "016e5d176bbaa827e0c237156b692649",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Location-Scale Ordinal Models\"\nformat: \n  html:\n    toc: true\nbibliography: \"https://raw.githubusercontent.com/filippogambarota/bib-database/main/references.bib\"\ncsl: \"https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl\"\n---\n\n\n\n\n## Scale Effects\n\nThe default ordinal regression model assume that the variance of the underlying latent distribution is the same across conditions. This is similar to a standard linear regression assuming the homogeneity of variances. \n\nFor example, when comparing two groups or conditions we can run a standard linear model (i.e., a t-test) assuming homogeneity of variances or using the Welch t-test [see @Delacre2017-qy] that relaxes the assumption. In addition, there are the so-called location-scale models that allows to include predictors also for the scale (e.g., the variance) of the distribution. \n\nThis can be done also in ordinal regression where instead of assuming the same variance between conditions, the linear predictors can be included. The Equations [-@eq-scale-location] and [-@eq-latent-scale-location] expand the standard model including the linear predictor on the scale of the latent distribution.\n\n$$\nP(Y \\leq k) = g^{-1}\\left(\\frac{\\alpha_k - \\mathbf{X}\\boldsymbol{\\beta}}{e^{\\boldsymbol{Z}\\boldsymbol{\\zeta}}}\\right)\n$$ {#eq-scale-location}\n\n$$\nY^\\star = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\epsilon} \\;\\;\\; \\epsilon_i \\sim \\mathcal{N}(0, e^{Z\\zeta})\n$$ {#eq-latent-scale-location}\n\nWhere $X\\zeta$ is the linear predictor for the scale of the distribution. By default for both the *logit* and *probit* model the scale is fixed to 1. On scale-location models we put predictors on both parameters. Given that the scale cannot be negative we use a log link function $\\eta = \\text{log}(X\\zeta)$. As suggested by @Tutz2017-de location-scale models can be considered as a more parsimonious approach compared to partially or completely relaxing the proportional odds assumption. Allowing the scale to be different as a function of the predictor create more modelling flexibility. Furthermore, two groups could be theoretically different only in the scale of the latent distribution with a similar location. In this example, the only way to capture group differences is by including a scale effect. The @fig-scale-effect-example depict the impact of having different scales between two groups on the ordinal probabilities but the same location. Clearly, there is no location effect and the two groups are predicted to be the same considering only the location effect.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat_latent_plot(location = c(0, 0), scale = c(1, 2), prob0 = rep(1/4, 4), link = \"logit\", plot = FALSE) |> \n  cowplot::plot_grid(plotlist = _, nrow = 1)\n```\n\n::: {.cell-output-display}\n![](location-scale-models_files/figure-html/fig-scale-effect-example-1.svg){#fig-scale-effect-example width=672}\n:::\n:::\n\n\n\n@Tutz2022-dg provide a very clear and intuitive explanation of what happen when including a scale effect and how to interpret the result. As suggested before, the scale-location model allow to independently predict changes in the location and the scale. While location shifts are simply interpreted as increasing/decreasing the latent $\\mu$ or the odds of responding a certain category scale effects are not straightforward. As the scale increase (e.g., the variance increase) there is an higher probability mass on extreme categories. On the other side as the scale decrease, responses are more concentrated on specific categories. \n\nThe location parameter determine the category and the scale determine the concentration around the category. For example, if one group have a certain latent mean $\\mu_1$ and a small scale $\\sigma^2 = 1/3$ (thus one third compared to the standard version of the distribution), all responses will be focused on categories around the latent mean. On the other side, increasing the scale will increase the cumulative probabilities for all categories and for values that tends to infinity extreme categories are preferred. The scale parameter can somehow be interpreted as the **response style**.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](location-scale-models_files/figure-html/fig-sigma-1.svg){#fig-sigma width=960}\n:::\n:::\n\n\n### Simulating scale effects\n\nThe location-scale model can be simulated using the `sim_ord_latent()` function and providing the predictors for the scale parameters. Given the `log` link function, predictors are provided on the `log` scale. For example, we simulate the effect of a binary variable $x$ representing two independent groups predicting the $k = 5$ response. We simulate a *location* effect of $\\beta_1 = 0.5$ (in *probit* scale) and $\\zeta_1 = \\text{log}(2) = 0.70$. The first group has a $\\sigma = 1$ and the second group has $\\sigma = 2$. Again we simulate that the baseline probabilities are uniform for the first group. The $\\log$ link function (and $e$ as inverse link function) is used to make sure that the variance is always positive. If the first group has a scale of 1 and the second group a scale of 2, the $\\zeta_1 = \\log(\\frac{s_2}{s_1}) = \\log(\\frac{2}{1}) \\approx 0.7$. Thus the two groups have a log difference in terms of scale of 0.7 (or a ratio of 2).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 5  # number of options (1)\nn <- 1e5 # number of observations (1)\nb1 <- 0.5 # beta1, the shift in the latent distribution (2)\nz1 <- log(2) # zeta1, the change in the scale\nprobs0 <- rep(1/k, k) # probabilities when x = 0 (3)\nalphas <- prob_to_alpha(probs0, link = \"probit\") # get true thresholds from probabilities (3)\ndat <- data.frame(x = rep(c(0, 1), each = n/2))\ndat <- sim_ord_latent(~x, scale = ~x, beta = b1, zeta = z1, prob0 = probs0, data = dat, link = \"probit\")\nfit <- clm(y ~ x, scale = ~ x, data = dat, link = \"probit\")\nsummary(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nformula: y ~ x\nscale:   ~x\ndata:    dat\n\n link   threshold nobs  logLik     AIC       niter max.grad cond.H \n probit flexible  1e+05 -151151.38 302314.76 11(0) 7.09e-07 3.2e+01\n\nCoefficients:\n  Estimate Std. Error z value Pr(>|z|)    \nx  0.50451    0.01176   42.89   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nlog-scale coefficients:\n  Estimate Std. Error z value Pr(>|z|)    \nx 0.701164   0.008418   83.29   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nThreshold coefficients:\n     Estimate Std. Error z value\n1|2 -0.835177   0.006287 -132.84\n2|3 -0.254419   0.005425  -46.90\n3|4  0.248568   0.005411   45.93\n4|5  0.829602   0.006277  132.17\n```\n\n\n:::\n:::\n\n\nTo better understand the impact of assuming (or simulating) a different latent scale we fit $k - 1$ binomial regressions and check the estimated coefficients. We are not simulating a specific beta for each outcome but simulating a scale effect is actually impacting the regression coefficients. When generating data for a binary outcome the linear predictor is composed by $\\eta = \\beta_0 + \\beta_1x$. The threshold $\\alpha$ and slope of the function can be estimated using $\\alpha = -\\frac{\\beta_0}{\\beta_1}$ and the slope is $\\frac{1}{\\beta_1}$ [@Knoblauch2012-to; @Faraggi2003-hm]. Under the proportional odds assumption, there is only a change in thresholds $\\alpha$ this a shift in the sigmoid along the $x$ axis. When including a scale effect a change in the sigmoid is combined with a change in the slope.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2023)\nk <- 4\nn <- 1e5\nb1 <- 3\nd1 <- log(2)\ndat <- data.frame(x = runif(n))\ndat <- sim_ord_latent(~x, ~x, beta = b1, zeta = d1, prob0 = rep(1/k, k), data = dat, link = \"probit\")\n\ndat$y1vs234 <- ifelse(dat$y <= 1, 1, 0)\ndat$y12vs34 <- ifelse(dat$y <= 2, 1, 0)\ndat$y123vs4 <- ifelse(dat$y <= 3, 1, 0)\n\ndat$y <- ordered(dat$y)\nfit <- clm(y ~ x, scale = ~x, data = dat, link = \"probit\")\n\nfit1vs234 <- glm(y1vs234 ~ x, data = dat, family = binomial(link = \"probit\"))\nfit12vs34 <- glm(y12vs34 ~ x, data = dat, family = binomial(link = \"probit\"))\nfit123vs4 <- glm(y123vs4 ~ x, data = dat, family = binomial(link = \"probit\"))\n\nfits <- list(y1vs234 = fit1vs234, fit12vs34 = fit12vs34, fit123vs4 = fit123vs4)\n\nlapply(fits, function(x) coef(x)) |> \n  bind_rows(.id = \"model\") |> \n  mutate(xp = list(seq(0, 5, 0.01))) |> \n  unnest(xp) |> \n  ggplot(aes(x = xp, y = `(Intercept)` + x * xp)) +\n  geom_line(aes(color = model)) +\n  theme_minimal(15)\n```\n\n::: {.cell-output-display}\n![](location-scale-models_files/figure-html/unnamed-chunk-5-1.svg){width=672}\n:::\n:::\n\n\n### Parallel slopes with scale effects\n\nWhen fitting a model with `clm()` the way of relaxing the proportional odds or parallel slopes assumption is including what is called a *nominal* effect. Basically when a predictor is included as a nominal effect, there will be $k - 1$ coefficients (where $k$ is the number of ordered levels). In this way, the odds ratio or the difference in $z$ scores will not be the same across $k$ levels.\n\nIf a scale effect is included in `clm()` is not immediately clear what happens to the proportional odds assumption. In fact, we are still estimating a single $\\beta$ but we have extra parameters on the scale of the distribution. However, changing the scale of the distribution is the same as changing the slope. This is clear from @fig-scale-slope-effect where changing the scale of the latent distribution is the same as changing the slope of the cumulative probability function. The slope ($\\beta_1$) is related to the scale of the distribution (logistic or normal) as $\\beta_1 = \\frac{1}{s}$. In fact, if we include a scale effect we are changing the scale of the underlying latent distribution and thus the slope of of the functions.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](location-scale-models_files/figure-html/fig-scale-slope-effect-1.svg){#fig-scale-slope-effect width=768}\n:::\n:::\n\n\nIn fact, if we simulate a model with a scale effect, odds ratios or $z$ differences are no longer constant.\n\nWe will simulate the following situation where a binary predictor $x$ has an effect both on location and scale of the logistic distribution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nodds <- function(p) p / (1 - p)\n\nn <- 1e4 # large N\nk <- 4\nb1 <- log(3)\nz1 <- log(2)\ndat <- data.frame(x = rep(c(0, 1), each = n))\ndat <- sim_ord_latent(~x, ~x, beta = log(3), zeta = log(2), prob0 = rep(1/k, k), data = dat, link = \"logit\")\n\n# model with scale effects, log(odds ratios) are different\n\nfit <- clm(y ~ x, scale = ~ x, data = dat, link = \"logit\")\n\npreds <- predict(fit, newdata = data.frame(x = c(0, 1)))$fit\npcum <- t(apply(preds, 1, cumsum))[, 1:(k - 1)]\n\napply(pcum, 2, function(c) log(odds(c[1])/odds(c[2])))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         1          2          3 \n-0.0436072  0.5202012  1.0755903 \n```\n\n\n:::\n\n```{.r .cell-code}\n# model without scale effects, log(odds ratios) are equal\n\nfit0 <- clm(y ~ x, scale = ~ 1, data = dat, link = \"logit\")\npreds <- predict(fit0, newdata = data.frame(x = c(0, 1)))$fit\npcum <- t(apply(preds, 1, cumsum))[, 1:(k - 1)]\napply(pcum, 2, function(c) log(odds(c[1])/odds(c[2])))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        1         2         3 \n0.6107211 0.6107211 0.6107211 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncat_latent_plot(c(0, 0 + b1), s = c(exp(0), (exp(0) + z1)), prob0 = rep(1/k, k), link = \"logit\")\n```\n\n::: {.cell-output-display}\n![](location-scale-models_files/figure-html/unnamed-chunk-8-1.svg){width=672}\n:::\n:::\n\n\n\nActually we can model this dataset using a non-proportional odds model. The model correctly capture the more complex probability structure but we are not able to recover the parameters because we simulated a scale effect.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_nominal <- clm(y ~ 1, nominal = ~ x, data = dat, link = \"logit\")\nsummary(fit_nominal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nformula: y ~ 1\nnominal: ~x\ndata:    dat\n\n link  threshold nobs  logLik    AIC      niter max.grad cond.H \n logit flexible  20000 -26016.82 52045.65 8(0)  3.82e-12 7.8e+01\n\nThreshold coefficients:\n                Estimate Std. Error z value\n1|2.(Intercept) -1.12600    0.02325 -48.421\n2|3.(Intercept) -0.01120    0.02000  -0.560\n3|4.(Intercept)  1.09063    0.02305  47.320\n1|2.x            0.04227    0.03271   1.292\n2|3.x           -0.51759    0.02879 -17.981\n3|4.x           -1.07663    0.03052 -35.281\n```\n\n\n:::\n:::\n\n\nEssentially we estimated two sets of thresholds one for the group 0 and one for the group 1. The difference with the previous model (beyond the fact that data are generated under a scale-location model) is that we need more parameters in a non-proportional odds model compared to the scale-location model. This is also more relevant when including more predictors. Also the likelihood ratio test correctly suggest that there is no relevant difference in the likelihood of the two models.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(fit, fit_nominal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLikelihood ratio tests of cumulative link models:\n \n            formula: nominal: scale: link: threshold:\nfit         y ~ x    ~1       ~x     logit flexible  \nfit_nominal y ~ 1    ~x       ~1     logit flexible  \n\n            no.par   AIC logLik LR.stat df Pr(>Chisq)\nfit              5 52044 -26017                      \nfit_nominal      6 52046 -26017  0.0478  1     0.8269\n```\n\n\n:::\n:::\n\n\n## Location Shift Models\n\nThe location-shift model is considered an alternative way to include dispersion effects (together with location effects) [@Tutz2022-dg; @Tutz2017-de; @Tutz2020-xq]. The core of the models is including predictors on the thresholds $\\alpha$ to decrease/increase the probability of response categories $k$ together with the parameters on the location $\\boldsymbol{\\beta}$\n\nThey are similar to the location-scale models in terms of parsimony but different in terms of parameters interpretation. Given that these models cannot be directly fitted by the `ordinal` package we are not going into details but we included some references to understand the model parametrization. The models are implemented in the `ordDisp` R package (https://cran.r-project.org/web/packages/ordDisp/index.html).\n\nHowever, as noted by Berger and Tutz^[https://www.researchgate.net/profile/Gerhard-Tutz/publication/305082385_Modelling_of_Varying_Dispersion_in_Cumulative_Regression_Models/links/578115fd08ae9485a43bd0f0/Modelling-of-Varying-Dispersion-in-Cumulative-Regression-Models.pdf] there is a correspondence between the partial proportional odds model and the location-shift model. Let's simulate a model with a scale effect where the true model has a scale effect:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ordinal)\nlibrary(ordDisp)\n\nn <- 1e3\nk <- 3 # number of ordinal levels\nprobs0 <- rep(1/k, k) # baseline probabilities\n\ndat <- data.frame(x = rep(c(0, 1), each = n))\n\ndat <- sim_ord_latent(~x, ~x, \n                      beta = b1, zeta = z1, \n                      prob0 = probs0, \n                      link = \"logit\", \n                      data = dat, \n                      simulate = TRUE)\n\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y          ys\n1 0 1 -2.51596242\n2 0 3  4.14198274\n3 0 2 -0.06790548\n4 0 2  0.43393823\n5 0 1 -1.86065820\n6 0 3  0.87618582\n```\n\n\n:::\n:::\n\n\nNow let's fit the location-shift model and the non-proportional odds model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_shift <- ordDisp(y ~ x|x, data = dat)\nfit_nopo <- clm(y ~ 1, nominal = ~x, data = dat, link = \"logit\")\n\nsummary(fit_shift)\n## \n## Call:\n## vglm(formula = formula1, family = cumulative(parallel = FALSE ~ \n##     1, reverse = reverse), data = DM, form2 = formula2, xij = formula3, \n##     checkwz = FALSE)\n## \n## Coefficients: \n##               Estimate Std. Error z value Pr(>|z|)    \n## (Intercept):1 -0.71724    0.06736 -10.649  < 2e-16 ***\n## (Intercept):2  0.65884    0.06671   9.876  < 2e-16 ***\n## xx            -0.43974    0.08410  -5.229 1.71e-07 ***\n## xz            -0.63838    0.08481  -7.527 5.18e-14 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Names of linear predictors: logitlink(P[Y<=1]), logitlink(P[Y<=2])\n## \n## Residual deviance: 4203.753 on 3996 degrees of freedom\n## \n## Log-likelihood: -2101.876 on 3996 degrees of freedom\n## \n## Number of Fisher scoring iterations: 3 \n## \n## No Hauck-Donner effect found in any of the estimates\n## \n## \n## Exponentiated coefficients:\n##        xx        xz \n## 0.6442065 0.5281488\nsummary(fit_nopo)\n## formula: y ~ 1\n## nominal: ~x\n## data:    dat\n## \n##  link  threshold nobs logLik   AIC     niter max.grad cond.H \n##  logit flexible  2000 -2101.88 4211.75 6(0)  9.75e-08 3.2e+01\n## \n## Threshold coefficients:\n##                 Estimate Std. Error z value\n## 1|2.(Intercept) -0.71724    0.06736 -10.649\n## 2|3.(Intercept)  0.65884    0.06671   9.876\n## 1|2.x           -0.12055    0.09634  -1.251\n## 2|3.x           -0.75892    0.09198  -8.251\n```\n:::\n\n\nFirstly, there is a correspondence in the baseline thresholds:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# location-shift model\ncoef(fit_shift)[1:(k - 1)]\n## (Intercept):1 (Intercept):2 \n##    -0.7172447     0.6588411\n\n# non proportional odds model\ncoef(fit_nopo)[1:(k - 1)]\n## 1|2.(Intercept) 2|3.(Intercept) \n##      -0.7172447       0.6588411\n```\n:::\n\n\nThen also linear predictors $\\eta$ are the same:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# let's see the linear predictor for x = 1\n\n# location-shift model\npredict(fit_shift)[n + 1, ]\n## logitlink(P[Y<=1]) logitlink(P[Y<=2]) \n##         -0.8377921         -0.1000835\n\n# non proportional odds model\npredict(fit_nopo, newdata = data.frame(x = 1), type = \"linear.predictor\")$eta1[, -k]\n##          1          2 \n## -0.8377921 -0.1000835\n```\n:::\n",
    "supporting": [
      "location-scale-models_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}